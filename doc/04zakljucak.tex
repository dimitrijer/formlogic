\chapter{Zaključak}\label{zakljucak}
Kao konačni rezultat rada realizovana je veb aplikacija za polaganje testova od strane studenata i administraciju testova od strane profesora. Studentima se ovim omogućava polaganje testova u hodu, a profesorima lakše ocenjivanje i izrada novih testova.

Izrađeni sistem ima svega oko 2000 linija koda, od čega je 1500 linija Clojure izvornog koda, raspoređenih u 9 fajlova. Modularan je, tako da se lako nadograđuje. Lako se kompajlira, pakuje i distribuira, ili kao samostalna aplikacija ili kao kontejner za veb server. Ceo projekat je okačen na \textit{GitHub}-u na adresi \url{https://github.com/dimitrijer/formlogic}. Izvorni kod je objavljen pod Eclipse javnom licensom, te predstavlja softver otvorenog koda.

Autor je veoma zadovoljan krajnjim rezultatom, imajući u vidu da mu je to prvi projekat pisan u Clojure jeziku. Funkcionalno programiranje nudi jedan sasvim drugačiji aspekat u odnosu na OOP paradigmu. Potrebno je neko vreme kako bi odviklo od pisanja sekvencijalnog koda, sa kontrolnim strukturama kojima se kontroliše tok izvršavanja, sa eksplicitnim iteriranjem, klasama, promenljivama, stanjem objekata itd. Autoru je najteže bilo da se liši koncepta perzistentnog stanja. Međutim, nakon nekog vremena počinju da se ukazuju neke prednosti funkcionalnog programiranja. Čiste funkcije postaju izuzetno moćan alat za enkapsulaciju i apstrakciju. Komponovanjem ovakvih funkcija uz pomoć elementarnih operacija \texttt{map}, \texttt{reduce}, \texttt{apply}, \texttt{comp}, \texttt{partial}, \texttt{threading} makroa itd. moguće je postići izuzetno kompleksne operacije, a opet zadržati čitljivost koda, i jasno odvojene odgovornosti na nivou funkcija. Clojure kolekcije (vektori, liste, rečnici, setovi) su izuzetno zgodne za rad. Iako svaka operacija nad kolekcijama vraća novu kolekciju, one su veoma performantne, zahvaljujući optimizacijama ispod haube, te se prilikom pisanja koda uopšte ne obraća pažnja na ,,skupljanje smeća''. Lenje sekvence, koje se realizuju samo kada se pristupa elementima, omogućavaju apstraktne termine poput beskonačnih nizova, ili beskonačnih poziva funkcija. Rekurzija takođe postaje moćno oružje: Clojure ima podršku za repnu rekurziju pomoću \texttt{recur} operacije, pa nema bojazni od prekoračenja steka. Kako su sve vrednosti nepromenljive (\textit{immutable}), to programer većinu vremena ne mora da razmišlja o mehanizmima sinhronizacije. Kada je neophodno obezbediti atomičnost nad dodelom vrednosti, postoje proste CAS (\textit{compare and set}) primitive zvane atomi.

Autor želi da napomene da još uvek nije imao dovoljno prakse da bi stekao jasnu percepciju svih prednosti i mana ovakvog koncepta programiranja. Takođe, postoje koncepti u Clojure jeziku koje autor nije imao prilike da upotrebi: multimetode (dispečovanje na osnovu tipa argumenta), protokoli (slični interfejsima), rekordi (strukture podataka), makroi (veoma moćan koncept koji omogućava manipulisanje samim elementima jezika, tj. samo-modifikovanje koda), transakcije (implementacija \textit{Software Transactional Memory} sistema svojstvena Clojure-u, koja obezbeđuje korektnost i konzistentnost podataka prilikom obrade od strane više niti) itd. Jedno je sigurno, a to je da se autor veoma raduje budućem radu u ovom programskom jeziku.